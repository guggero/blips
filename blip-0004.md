```
bLIP: 4
Title: Lightning Node Connect (LNC)
Status: Draft
Author: Oliver Gugger (gugger@gmail.com)
        Olaoluwa Osuntokun <laolu32@gmail.com>
Created: 2023-03-27
Post-History: https://lightning.engineering/posts/2021-11-30-lightning-node-connect-deep-dive/
License: CC0
```

## Abstract

This bLIP describes Lightning Node Connect (LNC), a protocol for connecting to a
Lightning node in a secure, private way over an untrusted web server.
LNC leverages [Password Authenticated Key Exchange
(PAKE)](https://en.wikipedia.org/wiki/Password-authenticated_key_agreement) and
the [Noise Protocol Framework](https://noiseprotocol.org/noise.html) for secure
connections and a gRPC/WebSocket based transport mechanism to punch through NATs
and firewalls.

## Copyright

This bLIP is licensed under the CC0 license.

## Rationale

Connecting to a Lightning node over the internet is a common use case for many
users, as it allows to manage and use the node from a mobile phone. However, the
current established way of connecting to a node (like [LND
Connect](https://github.com/LN-Zap/lndconnect)) requires users to manually
manage the home router's port forwarding configuration and firewall rules, and
the node's TLS certificates and macaroons to connect to a node. Or use a
notoriously slow Tor based connection.

Lightning Node Connect improves on prior trust/access based efforts at solving
this problem by using a PAKE instead of manually managing TLS certificates and
macaroons.
Lightning Node Connect's PAKE is combined with the Noise Protocol Framework to
create a pairing flow where a user only needs to enter a short human-readable
passphrase (scan or click a link) to establish a secure end-to-end
encrypted/mutually-authenticated connection with an application.

While LNC was originally designed to connect a WASM based web client to an `lnd`
node over the internet, it can be used for any application that connects to any
Lightning node implementation. This bLIP describes the minimal protocol set that
is required for an interoperable secure connection protocol between any client
application and any Lightning node.
Optional or implementation specific features are outlined in the section
["Optional features"](#optional-features).

## Specification

LNC is a protocol suite that consists of three protocol layers:
 - **lnc-transport**: This layer creates the actual tunnel connection on both
   ends by creating an _outbound_ connection to an independent and untrusted
   proxy server. This layer can be compared to the IP layer on the internet, it
   offers a way to send data packets to an addressable recipient. This transport
   layer is considered to be unreliable as package loss or transmission
   interruptions can happen unexpectedly.
 - **lnc-transmission**: This layer addresses the issue of having an unreliable
   transport layer by adding a simple transmission control layer on top, similar
   to what TCP adds on top of IP. The [Go-Back-N
   ARQ](https://en.wikipedia.org/wiki/Go-Back-N_ARQ) algorithm makes sure data
   packets are received properly by the other side.
 - **lnc-noise**: This layer adds a masked key exchange handshake protocol as
   well as strong over-the-wire encryption by using
   [SPAKE2](https://datatracker.ietf.org/doc/draft-irtf-cfrg-spake2/) and [The
   Noise Protocol Framework](http://noiseprotocol.org/noise.html).

### Common parameters

The following sections specify each of the layers outlined above in full detail.
There are several terms and parameters that are used throughout all layers and
are thus defined in this common section:

**Pairing Phrase** (or connection phrase):
The pairing phrase consists of 10 mnemonic words out of the
[BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) word
list. It encodes the 110 bits of entropy that is used to mask the public keys
used in the handshake. The entropy is also used for deriving the proxy/mailbox
IDs.
The reason for choosing 10 as the number of words for the pairing phrase is a
compromise between security (more bits, more secure) and danger of confusion
(if we use 12 or more words, it could easily be confused with a mnemonic wallet
seed phrase).
Given there is no checksum and each BIP-39 word encodes 11 bits, the total
number of 110 bits is a bit awkward to represent when using full bytes (as
`110 / 8 = 13.57`). This can easily be addressed by adding two extra zero bits
for padding to reach the full 14 bytes.

**Pairing Entropy**:
The word "entropy" refers to the raw 110 bits of information encoded within the
pairing phrase described above.

**Mailbox Server**:
The LNC connection tunnel is established over a public, untrusted proxy server
called the "mailbox server". Anyone can run such a server, but both client and
server of an LNC connection need to be connected to the same mailbox server for
a connection to work. The mailbox server's host/port should therefore be part of
the connection information handed to a client application.
The default public server `mailbox.terminal.lightning.today:443` may be used as
a fallback if no mailbox server is defined.

### lnc-transport

The transport layer depends on a simple public mailbox proxy that acts as a
[TURN](https://en.wikipedia.org/wiki/Traversal_Using_Relays_around_NAT) relay.
The mailbox proxy/relay simply offers a buffered (hence the term "mailbox")
one-way connection stream. Two such half-duplex connection streams are combined
into a single, full-duplex communication channel.

The mailbox server's API is defined as a gRPC protocol buffer, because gRPC
(which is based on HTTP/2) offers an efficient streaming RPC implementations
that works across many programming languages. The alternative WebSocket
implementation for web based clients is described below as well.

A cipher box is a one-way, buffered mailbox stream, identified by a 512 bit
`stream_id`. The stream ID for the initial handshake is derived directly from
the pairing entropy. After the initial handshake is complete, the communication
is continued on mailboxes with stream IDs derived from a shared secret between
the server and client (see [lnc-noise](#lnc-noise)).

Because there is always a two-way connection (from server to client and from
client to server), the stream IDs for the two connections are identical but for
the last bit, which is flipped:

```text
# initial handshake stream IDs
initial_handshake_sid := sha512(pairing_entropy)

server_to_client := [64]byte(initial_handshake_sid)

client_to_server := copy(server_to_client)
client_to_server[63] = client_to_server[63] ^ 0x01
```

Once the initial handshake of the `lnc-noise` layer is complete, communication
is switched over to the long-term stream IDs which are derived as follows:

```text
# ECDH between local and remote static/long-term key
shared_key := local_static_priv * remote_static_pub
shared_secret := sha256(serialize_compressed(shared_key))

# long-term stream IDs
long_term_sid := sha512(hmac256(key => shared_secret, message => "mailbox"))

server_to_client := [64]byte(long_term_sid)

client_to_server := copy(server_to_client)
client_to_server[63] = client_to_server[63] ^ 0x01
```

#### Stream usage, message buffer size and blocking read/writes

The mailbox proxy implements a buffered connection, meaning that a sender can
post a message to the mailbox and disconnect, then a receiver can connect to the
same mailbox and read the message later on.
To limit the number of bytes needed to store in memory, the message buffer size
is defined as 4096 bytes.

A single stream can only be used by a single writer and a single reader at the
same time. A stream is considered occupied on the write side if there is a
writer connected and on the read side if a reader is connected.

Sending the first message (with a size below the buffer size) to a mailbox as a
sender completes immediately, as the buffer is empty. The next message can
however only be written once the buffer is cleared by reading it on the
receiver's end. That means a stream becomes blocking on the sender side if the
message buffer contains a message and on the reader side if the message buffer
is empty.

#### gRPC

As mentioned above, gRPC was chosen for its efficient design when it comes to
long-running streaming endpoints. The following protobuf definition defines the
4 RPC methods that are required for creating, deleting and using a hashmail
stream, also called a cipher box.

```protobuf
syntax = "proto3";

package hashmailrpc;

// HashMail exposes a simple synchronous network stream that can be used for
// various types of synchronization and coordination. The service allows
// authenticated users to create a simplex stream call a cipher box. Once the
// stream is created, any user that knows of the stream ID can read/write from
// the stream, but only a single user can be on either side at a time.
service HashMail {
    /*
    NewCipherBox creates a new cipher box pipe/stream given a valid
    authentication mechanism. If the authentication mechanism has been revoked,
    or needs to be changed, then a CipherChallenge message is returned.
    Otherwise the method will either be accepted or rejected.
    */
    rpc NewCipherBox (CipherBoxAuth) returns (CipherInitResp);

    /*
    DelCipherBox attempts to tear down an existing cipher box pipe. The same
    authentication mechanism used to initially create the stream MUST be
    specified.
    */
    rpc DelCipherBox (CipherBoxAuth) returns (DelCipherBoxResp);

    /*
    SendStream opens up the write side of the passed CipherBox pipe. Writes
    will be non-blocking up to the buffer size of the pipe. Beyond that writes
    will block until completed.
    */
    rpc SendStream (stream CipherBox) returns (CipherBoxDesc);

    /*
    RecvStream opens up the read side of the passed CipherBox pipe. This method
    will block until a full message has been read as this is a message based
    pipe/stream abstraction.
    */
    rpc RecvStream (CipherBoxDesc) returns (stream CipherBox);
}

message ProofOfNode {
    // TODO(roasbeef): add proof of work, proof of channel or proof of on-chain
    // funds here.
}

message CipherBoxAuth {
    // A description of the stream one is attempting to initialize.
    CipherBoxDesc desc = 1;

    oneof auth {
       ProofOfNode auth = 2;
    }
}

message DelCipherBoxResp {
}

message CipherChallenge {
    // TODO(roasbeef): payment request, node key, etc, etc.
}

message CipherError {
}

message CipherSuccess {
    CipherBoxDesc desc = 1;
}

message CipherInitResp {
    oneof resp {
        /*
        CipherSuccess is returned if the initialization of the cipher box was
        successful.
        */
        CipherSuccess success = 1;

        /*
        CipherChallenge is returned if the authentication mechanism was revoked
        or needs to be refreshed.
        */
        CipherChallenge challenge = 2;

        /*
        CipherError is returned if the authentication mechanism failed to
        validate.
        */
        CipherError error = 3;
    }
}

message CipherBoxDesc {
    bytes stream_id = 1;
}

message CipherBox {
    CipherBoxDesc desc = 1;

    bytes msg = 2;
}
```

#### REST implementation

The gRPC interface is efficient for the node/server to connect to the mailbox
proxy, but a web client is unable to perform native gRPC requests. For that
reason a REST mapping with WebSocket streaming support must also be implemented
by a proxy server:

```yaml
type: google.api.Service
config_version: 3

http:
  rules:
    - selector: hashmailrpc.HashMail.NewCipherBox
      post: "/v1/lightning-node-connect/hashmail"
      body: "*"
    - selector: hashmailrpc.HashMail.DelCipherBox
      delete: "/v1/lightning-node-connect/hashmail"
    - selector: hashmailrpc.HashMail.SendStream
      post: "/v1/lightning-node-connect/hashmail/send"
      body: "*"
    - selector: hashmailrpc.HashMail.RecvStream
      post: "/v1/lightning-node-connect/hashmail/receive"
      body: "*"
```

#### Authentication

As a denial-of-service protection mechanism for the proxy server, a server
requesting to create a mailbox for sending/receiving needs to provide some form
of authentication.

TODO(guggero): Not yet implemented.

#### Future optimizations

Possible improvements to discuss:
 - Because two mailboxes are always required for full-duplex communication,
   they could be created with a single RPC and offer a bi-directionally
   streaming endpoint.

### lnc-transmission

The transmission control layer is tasked with guaranteeing that packets arrive
correctly and fully on the other side when being sent over the unreliable
mailbox proxy connection.
The [Go-Back-N Automatic repeat
request](https://en.wikipedia.org/wiki/Go-Back-N_ARQ) algorithm is used to add
reliable transmission to LNC, also referenced here by its acronym GBN.

The default value for the parameter `N` used in LNC is 20, but a different
parameter can be specified during the GBN handshake. A frame transmitted by GBN
is a simple data structure of a single byte frame type, followed by the frame
payload. Because the hashmail layer transmits a frame in full, independent of
its size (given we stay below the 4096 bytes of message buffer size), there is
no need to define and transmit payload lengths.

#### Frame types

```text
SYN frame
+-----------------------------+
| Type (8) = 0x01   | N (8)   |
+-----------------------------+
```
The `SYN` frame indicates the beginning of a connection attempt. It should
always be the first frame sent from the client to the server, indicating what
value of `N` to use for the GBN. The server then confirms by sending a `SYN`
frame back with the same value of `N`.


```text
DATA frame
+---------------------------------------------------------------------------+
| Type (8) = 0x02   | Seq (8)   | Final (8)   | Ping (8)   | Payload (0...) |
+---------------------------------------------------------------------------+
```



```text
ACK frame
+-------------------------------+
| Type (8) = 0x03   | Seq (8)   |
+-------------------------------+
```


```text
NACK frame
+-------------------------------+
| Type (8) = 0x04   | Seq (8)   |
+-------------------------------+
```


```text
FIN frame
+-------------------+
| Type (8) = 0x05   |
+-------------------+
```


```text
SYNACK frame
+-------------------+
| Type (8) = 0x06   |
+-------------------+

```

#### Message flow

The GBN handshake looks like this:

```text

  client                                server
     |    SYN (N=20)  --->                 |
     |                <---  SYN (N=20)     |
     |        SYNACK  --->                 |
```

After that short two-way handshake both sides can start sending data.

A simple send operation from client to server with no transmission errors is
expected to look like this:

```text

  client                                server
     |  DATA (SEQ=0)  --->                 |
     |                <---  ACK (SEQ=0)    |
     |  DATA (SEQ=1)  --->                 |
     |                <---  ACK (SEQ=1)    |
     |  DATA (SEQ=2)  --->                 |
     |                <---  ACK (SEQ=2)    |
    ...                                   ...
     |  DATA (SEQ=20) --->                 |
     |                <---  ACK (SEQ=20)   |
     |  DATA (SEQ=0)  --->                 |
     |                <---  ACK (SEQ=0)    |
     |  DATA (SEQ=1)  --->                 |
     |                <---  ACK (SEQ=1)    |
     |  DATA (SEQ=2)  --->                 |
     |                <---  ACK (SEQ=2)    |
    ...                                   ...
```

If no `ACK` is received from the server in time, according to the GBN resend
timeout, the client will re-send the packets. If the server receives packets out
of order it will send a `NACK` frame with the sequence number of the last good
packet received.

#### Default values

The following default values were chosen for the reference implementation:

| Description       | Value |
|-------------------|-------|
| N                 | 20    |
| Resend timeout    | 1s    |
| Handshake timeout | 2s    |
| Ping timeout      | 7s    |
| Pong timeout      | 3s    |

### lnc-noise

The [The Noise Protocol Framework](http://noiseprotocol.org/noise.html) is
divided into a series of handshake protocols, each with unique capabilities,
such as enabling zero round-trip connection establishment.
For LNC, we've taken the Noise `XX` handshake, and augmented it with a variant
of Encrypted Key Exchange (EKE) based on a public key binding operation utilized
by [SPAKE2](https://datatracker.ietf.org/doc/draft-irtf-cfrg-spake2/).

At a high level, SPAKE 2 works by using the password to effectively blind a
public key, in a manner that only allows a participant to un-blind it with
knowledge of the passphrase, as well as a distinct generator point we'll refer
to as `M`. In practice, `M` is typically generated in a fashion that ensures
that no one knows the discrete logarithm (essentially the "private key") for the
point (typically known as a NUMS, or "Nothing Up My Sleeve" point).

LNC [ships with code that enables any part to
verify](https://github.com/lightninglabs/lightning-node-connect/blob/master/mailbox/numsgen/main.go)
the generator `M` used in the protocol was generated securely from the string
`"Lightning Node Connect"`, resulting in the following value:

```text
M = numsgen("Lightning Node Connect") = 0254a58cd0f31c008fd0bc9b2dd5ba586144933829f6da33ac4130b555fb5ea32c
```

The SPAKE2 protocol defines both an `M` and `N` value which _can_ be different,
but for LNC we use `M = N` for simplicity.

#### Two handshakes

LNC uses two handshakes: The first using SPAKE2 to exchange the long-term public
keys of both participants. Once the first handshake has completed, only the
second, shorter handshake is used for the remainder of the connection and all
future connections. The pairing phrase is only used for the first handshake and
can be discarded once the initial handshake is complete.

#### First handshake

The first handshake used is fully parameterized by the protocol name:
`Noise_XXeke+SPAKE2_secp256k1_ChaChaPoly_SHA256`. 
We use a similar set of cryptographic primitives as [BOLT
8](https://github.com/lightning/bolts/blob/master/08-transport.md), but then
augment the Noise `XX` handshake by blinding the first ephemeral key sent by the
initiator, thereby effectively "encrypting" the first ephemeral key sent.
The blinding operation is defined as:

```text
me = e + M*h(pw)
```

The responder is then able to un-blind the point only if they know the password
with the following operation:

```text
e = me - M*h(pw) = e + M*h(pw) - M*h(pw)
```

As apparent above, the blinded passphrase point cancels out, leaving only the
original ephemeral key. The Noise handshake transcript includes the ephemeral
point in the handshake transcript, which is used as associated data each time a
MAC check is required. As a result, if the initiator uses the wrong passphrase,
then the initial MAC check will fail, resulting in the pairing being aborted.

As specified in [`lnc-transport`](#lnc-transport), the first handshake is
exchanged over a mailbox with stream IDs derived from the pairing entropy.

#### Second handshake

Once the first handshake has completed, both parties know the long-term public
keys used by the other side. This allows them to switch the communication over
to a mailbox with stream IDs derived from a shared secret only they know.

The protocol used for all communication from this point on can simply be defined
as `Noise_KK_secp256k1_ChaChaPoly_SHA256`. The Noise `KK` handshake can be used
now because both parties are already aware of the other side's static key.

#### AEAD payload

The Noise Protocol Framework allows each handshake message to optionally attach
a portion of encrypted data appended to the normal handshake data (usually an
ephemeral or static public key). LNC uses this feature to allow the server (in
this case the user’s Lightning Node) to transmit a set of authentication tokens
to the initiator (the web or client application) during the handshake process,
which ensures that the web application is able to immediately communicate with
the node after the pairing has been completed.

The content of this authentication payload is application specific. The only
restriction the LNC protocol dictates is that it should be a set of
human-readable values in the format of [HTTP header
fields](https://www.rfc-editor.org/rfc/rfc2616#section-4.2).
For example:

```text
Authorization: Bearer <token>
```

Or, in the case of `lnd` a [scoped macaroon](#scoped-macaroon-authentication):
```text
Macaroon: <hex_encoded_macaroon>
```

## Security design goals

The reasons for choosing SPAKE2+noise are plentiful. The most important ones for
LNC are:
 - Identity hiding: The operator of the proxy server can not identify the
   parties involved in a communication stream, even when learning the pairing
   phrase (after the initial handshake has completed).
 - Server Authentication: Users have cryptographic certainty that they are
   communicating with their node.
 - Avoid replay attacks: Sending the same packets to a server that were recorded
   previously will resolve in a decryption error instead of possibly invoking a
   gRPC/REST command again.
 - Forward security: Even if the static long-term keys are leaked at some point,
   any previously recorded communication sessions cannot be decrypted.
 - Battle tested: The noise protocol framework is used in production by things
   like WhatsApp, WireGuard, the Lightning Network, I2P and many other projects.

## Mailbox server implementation

A reference implementation of a mailbox proxy server can be found in
[`aperture`](https://github.com/lightninglabs/aperture). While `aperture` has
many other features and was originally built as an [LSAT](https://lsat.tech)
aware reverse proxy, the hashmail/mailbox proxy server functionality can be
turned on by specifying the following part in the `conf.yaml`:

```yaml
hashmail:
  enabled: true
  
  # Allow a message every 20 ms.
  messagerate: 20ms
  
  # Allow bursts of up to 1k messages, then throttle.
  messageburstallowance: 1000
```

## Versioning

There currently only is a version field in the `lnc-noise` layer. The noise
handshake version is used to negotiate the version of noise handshake pattern
between server and client.

The noise handshake version `0` and `1` were used during development and are
deprecated. Only version `2` should be used.

In general, it is worth noting that the client is expected to be updated first,
given that it's easier to update a WASM binary on a website or a mobile App than
it is to update the server side stack. That's why during the handshake the
client is sending both a minimum and maximum supported version while the server
is expected to always answer with the maximum version it supports.

A version should be added to the `lnc-transport` and `lnc-transmission` when new
features are added in the future.

## Optional features

The current example implementation of
[`lightning-node-connect`](https://github.com/lightninglabs/lightning-node-connect)
was built with a specific use case in mind: Connect to an `lnd` node from a
website (using a WASM client). Some design choices were influenced by hat use
case and some optional features were added to the LNC protocol for that use
case. Those features should be seen as optional and not part of the protocol
itself, that's why they are described in this section.

### gRPC integration

The Golang gRPC library allows parts of the gRPC protocol stack to be swapped
out with custom implementations very easily. For example the TCP based socket
connection can easily be swapped out for the `lnc-transmission` implementation
and the TLS layer can be replaced by `lnc-noise`.

But gRPC is not required on any layer of the LNC stack for it to work. A pure
HTTP/WebSocket based implementation is possible (though such an implementation
does not yet exist as of the time of this writing).

Only the mailbox proxy SHOULD offer both the gRPC and REST/WebSocket interface
for the mailbox in order to support both types of clients.

### Scoped macaroon authentication

Using a scoped macaroon as the authentication payload in the AEAD of the Noise
handshake makes it easy for the client to inspect their permissions and to adapt
a UI accordingly. It also makes the LNC connection stateless on the transport
layers and the server side connection can easily be plugged into existing
authentication inspection code.

### QR code generation

A QR code should include the mnemonic words of the pairing phrase and the proxy
server used. 

Example (currently used by `lightning-terminal` to link to
https://terminal.lightning.engineering) with the mnemonic words, the `host:port`
of the mailbox proxy used and some additional human-readable context on the
session's scope:

```text
pupil large rocket cave ramp bag carpet suspect grow catalog||mailbox.terminal.lightning.today:443||Read-Only
```

As long as there are few client side applications that understand the "bare"
pairing information as displayed above, a full URL with that information encoded
as base64 might be used instead:
```text
https://terminal.lightning.engineering/#/connect/pair/cHVwaWwgbGFyZ2Ugcm9ja2V0IGNhdmUgcmFtcCBiYWcgY2FycGV0IHN1c3BlY3QgZ3JvdyBjYXRhbG9nfHxtYWlsYm94LnRlcm1pbmFsLmxpZ2h0bmluZy50b2RheTo0NDN8fFJlYWQtT25seQ==
```

Note that the pairing phrase is appended after the `#` sign, which means that
part of the URL is not sent to the server and can only be extracted by the web
application's browser context.

### WASM integration for web clients

gRPC calls are encoded in a way that makes them efficient in terms of size when
sent over the wire. That binary protobuf format is not easy to handle in a
JavaScript browser environment.
To facilitate easy interaction between a web application and a node's gRPC
endpoints, the [WASM
client](https://github.com/lightninglabs/lightning-node-connect/tree/master/cmd/wasm-client)
of the `lightning-node-connect` example implementation not only provides a
wrapper around the three protocol layers but also an auto-generated wrapper for
converting JavaScript calls with JSON requests/responses into gRPC calls.

Those wrappers are generated in the [same repository as the target gRPC
package](https://github.com/lightningnetwork/lnd/blob/master/lnrpc/lightning.pb.json.go)
and allow the use of [TypeScript based type definitions to be
generated](https://github.com/lightninglabs/lnc-core) and used from those same
gRPC protobuf definitions.

## Future improvements

The following improvements should be made to the protocol in future upgrades:
 - Add protocol versions to the `lnc-transport` and `lnc-transmission`
   handshakes to allow for easy upgrade of the layers individually.
 - Allow an `lnc-transport` session to be created with a single, di-directional
   streaming RPC/WebSocket, creating two related mailboxes at the same time and
   multiplexing the two half-duplex pipes into a single full-duplex one.
 - Improve `lnc-transmission` to include the expected number of frames to be
   transmitted in order to avoid needing to wait for an `ACK` after every frame.
